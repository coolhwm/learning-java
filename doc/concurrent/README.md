# Java 多线程 - 学习笔记

## 1. 基本概念
- 进程
	- 程序的执行过程，是动态性的；
	- 持有资源（共享内存，共享文件）和线程；
- 线程
	- 线程是进程中的一个实体，是被系统独立调度和分派的基本单位；
	- 同一个进程中有多个现成；
	- 线程共享进程的资源；
	- 计算机处理器一个核心只能同时执行一个线程；
- 线程交互
	- 互斥：资源竞争，等待；
	- 同步：线程间的互相配合；


## 2. 线程
### 2.1 创建线程
- `Runnable`：线程接口；
- `Thread`：线程类；

### 2.2 Thread 与 Rumnable
- 由于Java单继承的原因，实现`Runnable`接口实现线程时，还可以继承自自己的类；
- `Runnable`的代码可以被多个现成`Thread`实例共享，适合多个线程处理同一资源的情况；

### 2.2 线程类常用方法
- `Thread()`：构造方法，创建线程，可以指定`Runnable`或名称；
- `start()`：启动线程；
- `sleep()`：静态方法，休眠当前线程，可以指定休眠时间；
- `join()`：使其他线程等待当前线程终止；需要控制结束程序的地方非常有用；
- `yield()`：静态方法，当前线程释放处理资源，线程需要重新竞争；
- `currentThread()`：返回当前运行的线程引用；

### 2.3 停止线程
- `stop()`：已经过时，错误的方法，线程戛然而止，无法确定完成了那些工作；线程被强制关闭；
- `interrupt()`：并不能正确的停止线程，会设置中断状态，在执行`join`,`sleep`方法进入阻塞时会抛出`InterruptedException`，可以使用`isIntereupted()`方法获取中断状态；
- **正确的方法**：使用`volatile`的`boolean`退出标识，确保代码完整执行，不会突然中止；

### 2.4 线程同步
#### 2.4.1 基本概念
- 争用条件： 当多个线程同时共享访问统一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏，这种现象称为争用条件；
- 互斥：在同一时间能够有一个线程操作数据区；
- 同步： 线程间的通信机制，可以用某种方式告诉其他线程自己的操作已经结束；

#### 2.4.2 同步锁
- `synchronized(lock)`块：传入一个锁对象，同时只有一个线程可以进入同步块中；
- `synchronized`方法：将一个方法本身设置为锁对象，同时只有一个线程可以进入该方法；

#### 2.4.3 同步方法
- `wait()`：将当前线程放在该锁对象的`wait set`中；在资源不足时可以调用该方法进行等待；
- `notifyAll()`：唤醒所有在该锁对象上等待的线程；
- `notify()`：唤醒一个在该锁对象上等待的线程，随机的一条线程，无法具体控制；

> **临界区(Critical Section)**：当有线程进入临界区段时，其他线程或是进程必须等待，以确保这些共用资源是被互斥获得使用；
> **Wait Set**：线程等待区域，调用`wait()`方法时进入，`notify()`或`notifyAll()`被调用时释放；

#### 2.4.4 基本范例
``` java
private final Object lockObject = new Object();
public void func(){
	//同步块加锁
	synchronized (lockObject){
		//判断资源条件，防止重复加锁浪费资源
	    while(!condition){
	        //当前线程等待，让出CPU资源
	        lockObject.wait();
	    }
	}
}
//唤醒线程
lockObject.notifyAll();
```

### 2.5 守护线程
- 基本概念
	- 在后台运行，为其他前台线程服务；
	- 特点：一旦用户线程都运行结束，守护线程会随JVM一起结束工作；
	- 应用：数据库连接池中的监测线程，JVM虚拟机启动后的监测线程、垃圾回收线程；
- 使用方式
	- 在线程启动前调用`setDeamon(true)`；
	- 在守护线程中产生的新线程，也会成为守护线程；
	- 不是所有任务都可以分配给守护线程，比如资源读取；


## 3. 可见性
### 3.1 基本概念
- **可见性**：一个线程对共享变量值的修改，能够及时的被其他线程看到；
- **共享变量**：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量；

### 3.2 Java内存模型（JMM）
Java内存模型（`Java Memory Model`， `JMM`）描述了Java程序中各种变量（线程共享变量）的访问规则，遗迹在`JVM`中将变量存储到内存和从内存中读取出变量这样的底层细节；
- 主内存与工作内存
	- 所有的变量都存储在`主内存`中；
	- 每个线程都有自己独立的`工作内存`，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）；
- 内存访问的规定
	- 线程对共享变量的所有操作必须在自己的工作内存中进行，不能直接从主内存中读取；
	- 不同线程之间无法直接访问其他线程的工作内存中的变量，线程间变量值的传递必须通过主内存进行；
- 共享变量可见性的实现原理
	- 将工作内存1中更新过的变量刷新到主内存中；
	- 将主内存中的最新的共享变量的值属性到工作内存2中；
	- `可见性`即为线程1中修改的变量值，**及时**的被线程2看到了，即为`线程安全`；

### 3.3 Java可见性实现方式
- 语言层面支持的可见性
	- `synchornized`
	- `volatile`
	- `final`
- `JDK 1.5`后实现的
	- `java.until.concurrent.locks`
	- `java.until.concurrent.atomic`
- 导致共享变量在线程间不可见的原因
	- 线程的交叉执行；
	- 重排序集合线程交叉执行；
	- 共享变更新后的值没有在工作内存与主内存之间及时更新；
- 线程执行互斥代码过程
	- 获得互斥锁；
	- 清空工作内存；
	- 从至内存拷贝变量的最新副本到工作内存；
	- 执行代码；
	- 将更改后的共享变量刷新到主内存；
	- 释放互斥锁；
- 指令重排序
	- 代码的书写顺序与执行顺序不同，指令重排序是编译器或处理器为了提高性能而做的优化；
	- 指令重排序包括：编译器优化重排序、指令并行重排序、内存系统重排序；
	- `as-if-serial`：无论如何重排序，程序执行的结果应该和代码顺序执行的结果一致（Java保证单线程遵守该语义）；
	- 在多线程中程序交错执行，重排序可能造成内存可见性问题；

#### 3.3.1 synchornized
- `synchornized`的作用
	- 保证变量的可见性；
	- 保证代码执行的原子性；
- `synchornized`如何实现可见性
	- `synchronized`相当于加了一把锁，锁内部的方法同时只能有一个线程执行，保证了方法和代码块执行的原子性；
	- 执行的原子性避免的线程的交叉执行，基于`as-if-serial`语义，在单线程执行时，重排序等价不会影响结果；
	- 以上两点确保的变量的及时更新；
- `JMM`中对`synchornized`的规定
	- 线程解锁前，必须把共享变量的最新值刷新到主内存中；
	- 线程加锁时，必须清空工作内存中的变量值，从而使用共享变量时需要从主内存中重新获取最新的值；
	- 所以：线程解锁前对共享变量的修改在下次加锁时对其他线程可见；


#### 3.3.2 volatile
- `volatile`的作用
	- 保证变量的可见性，在任何时刻，不同线程总是可以看到该变量的最新值；
	- 不能保证变量复合操作的原子性；
- `volatile`如何实现内存可见性
	- 内存屏障
		- 对`volitle`变量执行写操作时，会在操作后加入一条`store`屏障指令， 将变量的值及时刷入主内存；
		- 对`volitle`变量执行读操作时，会在操作后加入一条`load`屏障指令，将变量的最新值读入主内存；
	- 禁止指令重排序
- 适用场合
	- 对变量的写入操作不依赖其当前值；
	- 该变量没有包含在具有其他变量的不变式中；


## 4. 继续学习
- JMM, happens-before
- Locks & Condition
- 线程安全，原子性、可见性、atomic、DeadLocks、可见性编程
- 多线程交互模型： Future, Worker Thread, 
- 并发编程工具 concurrent , ExcutorService， Callable, Future, BlockingQueue
- core java；